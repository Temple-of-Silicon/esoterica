---
phase: 19-scroll-video
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - site/src/components/ScrollVideo.astro
  - site/src/scripts/scroll-scrubber.js
  - site/src/pages/index.astro
  - site/src/styles/global.css
autonomous: false

must_haves:
  truths:
    - "Scrolling the hero section plays the video forward; scrolling back plays it in reverse"
    - "First frame displays immediately as poster state before any scrolling"
    - "Video frames are pre-extracted WebP images rendered to canvas (not video element scrubbing)"
    - "Page loads without jank -- scroll handler uses requestAnimationFrame throttling"
  artifacts:
    - path: "site/src/components/ScrollVideo.astro"
      provides: "Canvas element with poster frame and data attributes for scrubber"
      min_lines: 15
    - path: "site/src/scripts/scroll-scrubber.js"
      provides: "Scroll-to-frame sync logic with rAF throttling and frame preloading"
      min_lines: 80
    - path: "site/src/pages/index.astro"
      provides: "Updated page using ScrollVideo component instead of Image"
    - path: "site/src/styles/global.css"
      provides: "Canvas styling matching hero-bg behavior"
  key_links:
    - from: "site/src/scripts/scroll-scrubber.js"
      to: "site/public/video/meta.json"
      via: "fetch at init to get totalFrames"
      pattern: "fetch.*meta\\.json"
    - from: "site/src/scripts/scroll-scrubber.js"
      to: "site/public/video/frames/frame-NNNN.webp"
      via: "Image() load per frame index"
      pattern: "new Image.*frame-"
    - from: "site/src/scripts/scroll-scrubber.js"
      to: "canvas.getContext('2d')"
      via: "drawImage on scroll"
      pattern: "drawImage"
    - from: "site/src/pages/index.astro"
      to: "site/src/components/ScrollVideo.astro"
      via: "component import replacing Image"
      pattern: "import ScrollVideo"
---

<objective>
Build the scroll-driven video scrubber: an Astro component with a canvas element, a vanilla JS scroll handler that maps scroll position to frame index, and integrate it into the existing hero section replacing the static Image.

Purpose: This is the core feature -- visitors see Apple-style scroll-driven video playback. Scrolling forward plays the video; scrolling backward reverses it. The first frame shows immediately as a poster.

Output: ScrollVideo.astro component, scroll-scrubber.js module, updated index.astro and global.css.
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key source files:
@site/src/pages/index.astro
@site/src/styles/global.css
@site/astro.config.mjs

Plan 01 output (frame extraction):
- Frames at: /esoterica/video/frames/frame-0001.webp through frame-NNNN.webp
- Metadata at: /esoterica/video/meta.json (contains totalFrames, fps, width, height)
- Base path is /esoterica (from astro.config.mjs base setting)

Architecture from research:
- Canvas element replaces Image component with identical CSS (.hero-bg class)
- Overlay ::before, z-index layering, theme toggle all work unchanged
- scroll event -> rAF throttle -> calculate progress (0-1) -> map to frame index -> load frame -> drawImage to canvas
- Preload first 15 frames (~1MB), lazy-load rest
- Intersection Observer to only run when hero section visible
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScrollVideo component and scroll-scrubber script</name>
  <files>
    site/src/components/ScrollVideo.astro
    site/src/scripts/scroll-scrubber.js
  </files>
  <action>
**ScrollVideo.astro component:**

Create `site/src/components/ScrollVideo.astro` that renders:
- A `<canvas>` element with class `hero-bg` and `id="scroll-video-canvas"`
- Data attributes: `data-base-path` set to the base URL for frames (use `import.meta.env.BASE_URL` to get `/esoterica/`)
- The canvas will be styled identically to the current `.hero-bg` img via CSS (absolute positioned, covering the hero)

```astro
---
// No props needed -- frame path derived from BASE_URL at runtime
const basePath = import.meta.env.BASE_URL;
---

<canvas
  id="scroll-video-canvas"
  class="hero-bg"
  data-base-path={`${basePath}video/frames/`}
  data-meta-path={`${basePath}video/meta.json`}
></canvas>
```

**scroll-scrubber.js module:**

Create `site/src/scripts/scroll-scrubber.js` with this architecture:

```javascript
// scroll-scrubber.js -- Scroll-driven video frame renderer
// Zero dependencies. Vanilla JS with native browser APIs.

(function() {
  const canvas = document.getElementById('scroll-video-canvas');
  if (!canvas) return;

  const ctx = canvas.getContext('2d');
  const basePath = canvas.dataset.basePath;
  const metaPath = canvas.dataset.metaPath;

  // State
  let totalFrames = 0;
  let frames = {};          // frame index -> Image object (cache)
  let currentFrame = -1;    // Track to avoid redundant draws
  let ticking = false;      // rAF throttle flag
  let heroEl = null;        // The .hero container for scroll bounds

  // --- Frame Loading ---

  function framePath(index) {
    // index is 1-based, zero-padded to 4 digits
    return basePath + 'frame-' + String(index).padStart(4, '0') + '.webp';
  }

  function loadFrame(index) {
    if (frames[index]) return frames[index];
    const img = new Image();
    img.src = framePath(index);
    frames[index] = img;
    return img;
  }

  function preloadRange(start, end) {
    for (let i = start; i <= Math.min(end, totalFrames); i++) {
      loadFrame(i);
    }
  }

  // --- Canvas Rendering ---

  function resizeCanvas() {
    // Match canvas pixel dimensions to its CSS display size
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    // Re-draw current frame after resize
    if (currentFrame > 0) drawFrame(currentFrame);
  }

  function drawFrame(index) {
    const img = loadFrame(index);
    if (!img.complete || !img.naturalWidth) {
      // Image not loaded yet -- draw when ready
      img.onload = () => {
        if (currentFrame === index) {
          drawFrameToCanvas(img);
        }
      };
      return;
    }
    drawFrameToCanvas(img);
  }

  function drawFrameToCanvas(img) {
    const rect = canvas.getBoundingClientRect();
    const cw = rect.width;
    const ch = rect.height;

    // Cover behavior (like object-fit: cover)
    const imgRatio = img.naturalWidth / img.naturalHeight;
    const canvasRatio = cw / ch;
    let drawW, drawH, offsetX, offsetY;

    if (canvasRatio > imgRatio) {
      drawW = cw;
      drawH = cw / imgRatio;
      offsetX = 0;
      offsetY = (ch - drawH) / 2;
    } else {
      drawH = ch;
      drawW = ch * imgRatio;
      offsetX = (cw - drawW) / 2;
      offsetY = 0;
    }

    ctx.clearRect(0, 0, cw, ch);
    ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
  }

  // --- Scroll Handling ---

  function getScrollProgress() {
    // Progress is 0 at top of hero, 1 at bottom of hero
    if (!heroEl) return 0;
    const rect = heroEl.getBoundingClientRect();
    const heroHeight = heroEl.offsetHeight;
    // scrolled = how far past the top of the hero we are
    const scrolled = -rect.top;
    // Clamp to 0-1
    return Math.max(0, Math.min(1, scrolled / heroHeight));
  }

  function onScroll() {
    if (ticking) return;
    ticking = true;
    requestAnimationFrame(() => {
      const progress = getScrollProgress();
      // Map progress 0-1 to frame 1-totalFrames
      const frameIndex = Math.max(1, Math.min(totalFrames, Math.round(progress * (totalFrames - 1)) + 1));

      if (frameIndex !== currentFrame) {
        currentFrame = frameIndex;
        drawFrame(frameIndex);

        // Preload nearby frames for smooth scrubbing
        preloadRange(Math.max(1, frameIndex - 5), Math.min(totalFrames, frameIndex + 15));
      }
      ticking = false;
    });
  }

  // --- Initialization ---

  async function init() {
    heroEl = canvas.closest('.hero');
    if (!heroEl) heroEl = canvas.parentElement;

    // Load metadata
    try {
      const res = await fetch(metaPath);
      const meta = await res.json();
      totalFrames = meta.totalFrames;
    } catch (e) {
      console.error('ScrollVideo: Failed to load meta.json', e);
      totalFrames = 240; // Fallback
    }

    // Size canvas
    resizeCanvas();

    // Preload first batch (poster + nearby frames)
    preloadRange(1, 15);

    // Draw first frame immediately as poster
    currentFrame = 1;
    const firstFrame = loadFrame(1);
    if (firstFrame.complete && firstFrame.naturalWidth) {
      drawFrameToCanvas(firstFrame);
    } else {
      firstFrame.onload = () => drawFrameToCanvas(firstFrame);
    }

    // Listen for scroll
    window.addEventListener('scroll', onScroll, { passive: true });

    // Handle resize
    window.addEventListener('resize', resizeCanvas);

    // Also handle initial scroll position (page may load scrolled)
    onScroll();
  }

  // Start when DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
```

Key design decisions and WHY:
- IIFE wrapper: No module system needed, keeps global scope clean
- `{ passive: true }` on scroll listener: Tells browser we won't call preventDefault, enabling scroll performance optimizations
- rAF throttle via `ticking` flag: Prevents scroll handler from firing faster than display refresh rate (eliminates jank)
- Frame cache object (not array): Sparse access pattern -- user may jump from frame 1 to frame 200
- Cover-fit math in drawFrameToCanvas: Replicates `object-fit: cover` behavior since canvas doesn't support it natively
- DPR-aware canvas sizing: Prevents blurry rendering on Retina displays
- Preload nearby frames on each scroll: Loads 5 behind and 15 ahead for smooth bidirectional scrubbing
- meta.json fetch instead of hardcoded count: Decouples frame extraction (Plan 01) from scrubber code
  </action>
  <verify>
- `ls site/src/components/ScrollVideo.astro` exists
- `ls site/src/scripts/scroll-scrubber.js` exists
- ScrollVideo.astro contains a canvas element with id="scroll-video-canvas" and data-base-path attribute
- scroll-scrubber.js contains: requestAnimationFrame, drawImage, new Image(), passive: true, meta.json fetch
- No npm dependencies added (check package.json unchanged)
  </verify>
  <done>
ScrollVideo.astro renders a canvas element with correct data attributes. scroll-scrubber.js implements scroll-to-frame mapping with rAF throttling, DPR-aware canvas rendering, object-fit:cover math, frame preloading, and meta.json-driven frame count.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ScrollVideo into hero section</name>
  <files>
    site/src/pages/index.astro
    site/src/styles/global.css
  </files>
  <action>
**Update index.astro:**

1. Replace the `<Image>` import and component with `ScrollVideo`:

Remove:
```astro
import { Image } from 'astro:assets';
import heroImage from '../assets/hero-primary.png';
```
And the `<Image ... />` element in the hero div.

Add:
```astro
import ScrollVideo from '../components/ScrollVideo.astro';
```
And place `<ScrollVideo />` where the `<Image>` was (first child of `.hero` div).

2. Add the scroll-scrubber script import. Use a `<script>` tag at the end of the page body:
```html
<script src="../scripts/scroll-scrubber.js"></script>
```
Astro will bundle this automatically.

Actually -- since Astro processes `<script>` tags, the cleanest approach is to import it directly:
```html
<script>
  import '../scripts/scroll-scrubber.js';
</script>
```
This ensures Astro bundles it properly with the page.

3. The hero section needs to be taller than viewport for scroll to work. The hero ALREADY has `min-height: 100vh`. But the video plays over the SCROLL distance of the hero, so the hero needs enough height for meaningful scroll travel. Add a `height: 200vh` to make the hero section 2x viewport height, giving a full viewport of scroll distance to play through all frames. The existing content (header, main, footer) stays positioned within the first viewport via flexbox.

IMPORTANT: Keep the existing `<Image>` import and element as a `<noscript>` fallback:
```html
<noscript>
  <Image src={heroImage} alt="Sacred altar with tarot cards" width={1920} quality={80} format="webp" class="hero-bg" />
</noscript>
```
This ensures the page still shows a hero image if JavaScript is disabled.

The final hero structure should be:
```html
<div class="hero">
  <ScrollVideo />
  <noscript>
    <Image ... class="hero-bg" />
  </noscript>
  <!-- ::before overlay (CSS, unchanged) -->
  <header>...</header>
  <main>...</main>
  <footer>...</footer>
</div>
```

**Update global.css:**

1. The `.hero-bg` class currently targets `img`. Canvas needs identical styling. The existing CSS uses `object-fit: cover` which doesn't apply to canvas (we handle this in JS with the cover-fit math). Add canvas-specific rule:

```css
canvas.hero-bg {
  /* Canvas doesn't support object-fit, cover behavior handled in JS */
  image-rendering: auto;
}
```

2. Update `.hero` to support scroll-driven height:

```css
.hero {
  position: relative;
  height: 200vh;          /* 2x viewport for scroll travel */
  display: flex;
  flex-direction: column;
  overflow: hidden;       /* Keep this -- clips canvas to hero bounds */
}
```

Remove `min-height: 100vh` and `min-height: 100svh` since we now use explicit `height: 200vh`.

3. Make the hero CONTENT sticky so it stays visible while scrolling through the hero section:

```css
.hero-content-wrapper {
  position: sticky;
  top: 0;
  height: 100vh;
  height: 100svh;
  display: flex;
  flex-direction: column;
}
```

Wait -- this requires a structural change to index.astro. The header, main, and footer need to be wrapped in a sticky container. Update the index.astro hero structure:

```html
<div class="hero">
  <ScrollVideo />
  <noscript>...</noscript>
  <div class="hero-content-wrapper">
    <header class="header">...</header>
    <main class="main">...</main>
    <footer class="footer">...</footer>
  </div>
</div>
```

And the `.hero-bg` (canvas) needs `position: fixed` during hero scroll to stay in viewport:

Actually, simpler approach: use `position: sticky` on the canvas too:

```css
.hero-bg {
  position: sticky;
  top: 0;
  width: 100%;
  height: 100vh;
  height: 100svh;
  z-index: 0;
}

canvas.hero-bg {
  display: block;
}
```

And make the content overlay sticky too:

```css
.hero-content-wrapper {
  position: sticky;
  top: 0;
  height: 100vh;
  height: 100svh;
  display: flex;
  flex-direction: column;
  z-index: 2;
  margin-top: -100vh;  /* Overlap the canvas */
}
```

The `margin-top: -100vh` pulls the content wrapper back up to overlap the canvas, creating the overlay effect.

4. Update `.hero::before` overlay to be inside the content wrapper (or keep it on `.hero` but ensure it's sticky too). Simplest: move the overlay to `.hero-content-wrapper::before`:

```css
.hero-content-wrapper::before {
  content: '';
  position: absolute;
  inset: 0;
  background: var(--bg-overlay);
  transition: background 0.3s ease;
  z-index: 1;
}
```

Remove the `.hero::before` rule since the overlay now lives on the sticky content wrapper.

5. Remove the old `min-height` values and `object-fit` from `.hero-bg` since canvas handles cover-fit in JS.

IMPORTANT GOTCHA: The `header`, `main`, `footer` within the hero all have `position: relative; z-index: 10`. These must stay to appear above the overlay. No change needed there.
  </action>
  <verify>
- `cd site && npm run build` completes without errors
- `cd site && npm run dev` starts the dev server
- Open `http://localhost:4321/esoterica/` in a browser
- First frame displays immediately (no blank state)
- Scrolling down through the hero section plays the video forward
- Scrolling back up reverses the video
- Header, tagline, install command are visible overlaying the video
- Theme toggle still works
- Prose section appears below the hero after scrolling past it
- No console errors related to scroll-scrubber.js
  </verify>
  <done>
ScrollVideo component integrated into the hero section. Canvas replaces static Image. Scrolling plays video forward/reverse. First frame shows as poster. Content overlays the canvas with sticky positioning. Hero is 200vh tall providing full scroll travel. Build succeeds, no jank, no console errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Scroll-driven video hero section. The source MP4 has been extracted to ~240 WebP frames. A canvas element renders frames based on scroll position. Scrolling forward plays the video; scrolling backward reverses it. The first frame shows immediately as a poster.
  </what-built>
  <how-to-verify>
1. Run `cd site && npm run dev` if not already running
2. Open http://localhost:4321/esoterica/ in Chrome
3. Verify: First frame of video is visible as the hero background (not a blank canvas)
4. Scroll down slowly -- video should play forward frame by frame
5. Scroll back up -- video should reverse smoothly
6. Verify: Header text, tagline, and install command are visible overlaying the video
7. Verify: Theme toggle (sun/moon icon) still works
8. Scroll past the hero section entirely -- prose section should appear normally
9. Resize the browser window -- canvas should adapt without distortion
10. Check browser console (F12) -- no errors related to scroll-scrubber
  </how-to-verify>
  <resume-signal>Type "approved" or describe any visual/behavioral issues</resume-signal>
</task>

</tasks>

<verification>
Phase 19 success requires ALL of these to be TRUE:
1. Scrolling the hero section plays the video forward; scrolling back plays it in reverse
2. First frame displays immediately as poster state before any scrolling
3. Video frames are pre-extracted WebP images rendered to canvas (not video element scrubbing)
4. Source video is compressed from 25MB original to optimized WebP frame sequence
5. Page loads without jank -- scroll handler uses requestAnimationFrame throttling
</verification>

<success_criteria>
- ~240 WebP frames exist in site/public/video/frames/
- Canvas element renders frames tied to scroll position
- First frame shows immediately (no flash of blank canvas)
- Scroll forward = video forward, scroll backward = video reverse
- rAF throttling prevents scroll jank
- Existing hero content (header, tagline, install) overlays the video
- Theme toggle, prose section, and all existing functionality preserved
- Build completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-scroll-video/19-02-SUMMARY.md`
</output>
