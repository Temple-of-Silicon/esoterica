---
phase: 22-footer-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - site/public/video/hero.mp4
  - site/src/scripts/scroll-scrubber.js
autonomous: true

must_haves:
  truths:
    - "Video scroll animation is smooth in Chrome (no lag or jank)"
    - "Poster is visible while video loads, hidden once ready"
    - "Video seeks smoothly at any scroll position"
  artifacts:
    - path: "site/public/video/hero.mp4"
      provides: "Optimized video with frequent keyframes"
      contains: "~24 I-frames (keyframe every 10 frames)"
    - path: "site/src/scripts/scroll-scrubber.js"
      provides: "Loading state management"
      contains: "canplaythrough"
  key_links:
    - from: "site/src/scripts/scroll-scrubber.js"
      to: "video#scroll-video"
      via: "canplaythrough event listener"
      pattern: "canplaythrough"
---

<objective>
Fix Chrome scroll animation lag and add video loading state detection.

Purpose: Chrome video seeking is laggy because the current hero.mp4 has only 1 keyframe across 242 frames. Re-encoding with keyframes every 10 frames enables Chrome to decode quickly. Additionally, the poster should remain visible until video is fully buffered.

Output: Re-encoded hero.mp4 with ~24 keyframes, scroll-scrubber.js with loading state logic.
</objective>

<execution_context>
@/Users/jem/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jem/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-footer-polish/22-RESEARCH.md
@site/src/scripts/scroll-scrubber.js
@site/src/components/ScrollVideo.astro
</context>

<tasks>

<task type="auto">
  <name>Task 1: Re-encode video with frequent keyframes</name>
  <files>site/public/video/hero.mp4</files>
  <action>
Re-encode hero.mp4 with keyframes every 10 frames to fix Chrome scroll lag:

```bash
cd site/public/video
# Backup original
cp hero.mp4 hero-original.mp4

# Re-encode with keyframes every 10 frames
ffmpeg -i hero-original.mp4 \
  -c:v libx264 \
  -crf 28 \
  -preset medium \
  -g 10 \
  -keyint_min 10 \
  -x264-params scenecut=0 \
  -profile:v main \
  -level 4.0 \
  -movflags +faststart \
  -an \
  hero.mp4

# Verify keyframe count (should be ~24 for 242 frame video)
ffprobe -v error -select_streams v:0 \
  -show_entries frame=pict_type \
  -of csv=print_section=0 hero.mp4 | grep -c "^I"

# Clean up backup after verification
rm hero-original.mp4
```

Expected file size increase from 1.8MB to ~2.2-2.5MB (acceptable tradeoff for smooth seeking).
  </action>
  <verify>
1. `ffprobe -v error -select_streams v:0 -show_entries frame=pict_type -of csv=print_section=0 site/public/video/hero.mp4 | grep -c "^I"` returns ~24
2. File size is under 3MB
3. Video still plays correctly when opened directly
  </verify>
  <done>hero.mp4 has ~24 I-frames (keyframe every 10 frames) and file size under 3MB</done>
</task>

<task type="auto">
  <name>Task 2: Add video loading state detection</name>
  <files>site/src/scripts/scroll-scrubber.js</files>
  <action>
Add loading state logic to scroll-scrubber.js to hide poster once video is ready for seeking:

1. After the video element is retrieved, add canplaythrough listener
2. When fired, hide the poster element (.hero-bg-poster)
3. Add timeout fallback for Safari iOS edge case (3 seconds)
4. Also check on loadeddata event as backup

The poster element already exists and is shown by default. The logic should:
- Query `.hero-bg-poster` element
- Set `display: none` when video is ready
- Use `{ once: true }` for event listeners to prevent repeat firing

Reference pattern from 22-RESEARCH.md:
```javascript
function hidePoster() {
  const poster = document.querySelector('.hero-bg-poster');
  if (poster) {
    poster.style.display = 'none';
  }
}

video.addEventListener('canplaythrough', hidePoster, { once: true });

setTimeout(() => {
  if (video.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA) {
    hidePoster();
  }
}, 3000);
```

Integrate this into the existing IIFE, placing the loading state logic BEFORE the reduced motion check returns early (so poster is always hidden eventually, even in reduced motion mode).
  </action>
  <verify>
1. `grep -n "canplaythrough" site/src/scripts/scroll-scrubber.js` shows the listener
2. `grep -n "hidePoster\|hero-bg-poster" site/src/scripts/scroll-scrubber.js` shows poster handling
3. Build succeeds: `cd site && npm run build`
  </verify>
  <done>scroll-scrubber.js has canplaythrough listener that hides poster when video is buffered, with timeout fallback</done>
</task>

</tasks>

<verification>
After completing both tasks:
1. Start dev server: `cd site && npm run dev`
2. Open Chrome at http://localhost:4321/esoterica/
3. Scroll through hero section - animation should be smooth (no jank)
4. Hard refresh (Cmd+Shift+R) - poster should be visible briefly then hidden
5. Check Safari for comparison - should now match Chrome smoothness
</verification>

<success_criteria>
- Video has ~24 keyframes (verified via ffprobe)
- Chrome scroll animation is smooth at any scroll position
- Poster is visible during initial load, hidden once video is ready
- Build succeeds with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/22-footer-polish/22-01-SUMMARY.md`
</output>
